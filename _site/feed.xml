<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-24T17:31:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">작은 걸음</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>pwsusc10</name></author><entry><title type="html">npm이란</title><link href="http://localhost:4000/til/2023/05/19/npm.html" rel="alternate" type="text/html" title="npm이란" /><published>2023-05-19T00:00:00+09:00</published><updated>2023-05-19T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/05/19/npm</id><content type="html" xml:base="http://localhost:4000/til/2023/05/19/npm.html"><![CDATA[<p>npm : Node Package Manager</p>

<p>npm init : package.json(project에 대한 정보) 생성
npm install [library] : [library] 설치<br />
npm uninstall [library] : [library] 삭제
npm version : (Major).(Minor).(Patch)</p>

<ul>
  <li>Major : 기능의 사용 방식이 변하거나, 기능 대거 추가 및 수정 등이 일어났을 때 업데이트</li>
  <li>Minor : 기능 추가등을 업데이트</li>
  <li>Patch : 출시한 버전에 오류가 발생하거나 사소한 버그로 인해 수정했을 때 업데이트</li>
</ul>

<p>npm list : 설치한 목록
npm list -g : global적으로 설치된 목록
package-lock.json : [library]의 버전과 정보들이 담겨 있다.
npm view [library] : library의 update된 정보들 확인
npm outdated : update가 필요한 [library]들을 보여줌
npm update : update가 필요한 [library]를 전부 update
npm update [library] : [library]를 update
option / –save-dev : devDependencies 개발에 필요한 library를 설치할 때의 옵션 - 제품 자체에 필요한 것이 아닌 개발에 필요한 것임<br />
npm install nodemon –save-dev</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Node" /><summary type="html"><![CDATA[npm : Node Package Manager]]></summary></entry><entry><title type="html">Node 소개</title><link href="http://localhost:4000/til/2023/05/17/node.html" rel="alternate" type="text/html" title="Node 소개" /><published>2023-05-17T00:00:00+09:00</published><updated>2023-05-17T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/05/17/node</id><content type="html" xml:base="http://localhost:4000/til/2023/05/17/node.html"><![CDATA[<h2 id="nodejs가-나오게-된-환경">Node.js가 나오게 된 환경</h2>

<h3 id="시간-별-나열">시간 별 나열</h3>

<p>1995년 이전에는 HTML, CSS로 웹사이트를 만듦<br />
1995년 JavaScript 도입 =&gt; 많은 브라우저들이 JS Engine을 탑제하기 시작</p>

<ul>
  <li>Safari : JavaScriptCore</li>
  <li>Internet Explorer : Chakara</li>
  <li>Firefox : SpiderMonkey</li>
  <li>Chrome : V8 - (JIT : Just-In-Time compilation)을 지원</li>
  <li>Edge : V8</li>
</ul>

<p>2009년 Ryan Dahl에 의해 Node.js 탄생 - JavaScript를 브라우저위에서만이 아닌 everywhere에서 사용하기 위함</p>

<h3 id="주요-기술">주요 기술</h3>

<p>V8 Engine?</p>

<ul>
  <li>오픈소스 JavaScript Engine중 하나</li>
  <li>JavaScript와 WebAssembly Engine</li>
  <li>JavaScript를 바이트코드로 컴파일하고 실행하는 방식을 사용</li>
</ul>

<p>WebAssembly?</p>

<ul>
  <li>C나 C++와 같은 프로그래밍 언어를 컴파일해서 어느 브라우저에서나 빠르게 실행되는 형식으로 바꿔주는 기술을 의미</li>
  <li>보통 웹 애플리케이션 개발시에는 JavaScript 프로그래밍 언어를 사용해 동적인 부분을 개발하는데 C나 C++언어들에 비해서는 느리다.</li>
  <li>게임이나 동영상 편집 등과 같은 고성능 웹 애플리케이션을 개발할 때 브라우저의 동작을 빠르게 하기위해서 C나 C++과 같은 언어로 개발할 수 있게 하는 것이다.</li>
  <li>고성능 웹 애플리케이션 개발 시 JavaScript와 같이 사용되고 JavaScript를 대체하는 것이 아닌 보완하는 기술인 것이다.</li>
</ul>

<h2 id="nodejs가-뭔데">Node.js가 뭔데?</h2>

<h4 id="정의">정의</h4>

<p>Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다.</p>

<p>“JavaScript everywhere”<br />
브라우저외 서버등에서도 JS를 사용할 수 있도록 하는 JavaScript runtime이다.</p>

<h3 id="runtime이란">runtime이란?</h3>

<p>runtime이란, 프로그래밍 언어가 구동되는 환경을 말한다.<br />
즉 Javascript runtime이란 JavaScript가 구동되는 환경을 말하는 것이다.<br />
JavaScript runtime의 종류는 웹 브라우저(Chrome, Firefox 등등)프로그램과 Node.js가 있다.</p>

<h3 id="nodejs의-특징">Node.js의 특징</h3>

<ol>
  <li>JavaScript Runtime</li>
  <li>Single Thread</li>
  <li>Non-Blocking I/O (Asynchrnous I/O)</li>
  <li>Event-Driven</li>
</ol>

<p>node.js는 single thread라는 특징을 갖고 있다. 즉 main thread, 하나의 thread로 구성되어 있다는 것이며 한번에 하나의 작업만 수행할 수 있다는 것을 의미한다. 그렇다면 어떻게 Non-Blocking I/O, 비동기등과 같은 상반되는 개념들을 갖고 있는 것일까?</p>

<h3 id="동작-원리">동작 원리</h3>

<p>우선 JavaScript의 동작 원리에 대해 알고 가야한다.
<img width="564" alt="스크린샷 2023-05-24 오후 12 59 41" src="https://github.com/pwsusc10/pwsusc10.github.io/assets/101408068/fe92fbf3-fc21-4b5c-996e-b8079602b875" /></p>

<ol>
  <li>
    <p>JavaScript Runtime은 메모리 힙과 콜 스택으로 구성되어있다.</p>

    <ul>
      <li>메모리 힙 : 메모리를 할당하는 곳</li>
      <li>콜 스택 : 코드가 호출되면서, 스택으로 쌓이는 곳(하나의 메인 스레드에서 호출되는 함수들이 콜 스택에 쌓인다. 함수들은 LIFO(Last-In First_Out)방식으로 처리)</li>
    </ul>
  </li>
  <li>JavaScript Runtime은 자체적으로 비동기를 지원하지 않는다.</li>
  <li>비동기, Non-blocking 처리들은 JavaScript Engine을 구동하는 Runtime 환경(Node.js, 브라우저)에서 담당한다.
    <ul>
      <li>런타임(runtime)과 엔진(Engine)의 관계는 전통적인 컴파일드 언어에서의 링커와 컴파일러의 관계와 같습니다.</li>
    </ul>
  </li>
  <li>즉 JavaScript의 Engine은 단지 코드에 대한 실행환경이며 각 이벤트를 스케줄링하는 것은 그것을 둘러싸고 있는 환경이다. 비동기 작업들도 이러한 환경에서 지원한다.</li>
</ol>

<p><img width="687" alt="스크린샷 2023-05-24 오후 4 46 14" src="https://github.com/pwsusc10/pwsusc10.github.io/assets/101408068/002e167f-38f9-4bd3-a72c-27f01f16bf4f" /></p>

<p>다음 이미지가 바로 JavaScript의 엔진과 외부의 런타임 환결등이 조합된 모습이다.</p>

<ul>
  <li>이벤트 루프: 이벤트 발생 시 호출되는 콜백 함수들을 관리하여 콜백 큐에 전달하고, 콜백 큐에 담겨있는 콜백 함수들을 콜스택에 넘겨줍니다.
    <ul>
      <li>이벤트 루프가 콜백 큐에서 콜스택으로 콜백 함수를 넘겨주는 작업은 콜스택에 쌓여있는 함수가 없을때만 수행됩니다.</li>
    </ul>
  </li>
  <li>콜백 큐: web api에서 비동기 작업들이 실행된 후 호출되는 콜백함수들이 기다리는 공간입니다. 이벤트 루프가 정해준 순서대로 줄을 서있으며, FIFO(First In First Out) 방식을 따릅니다.
    <ul>
      <li>콜백 큐는 하나의 큐로 이루어있지 않습니다. Microtask Queue, Animation Frames 등 여러개의 큐로 이루어져 있습니다. 단, 이 글에서는 이해의 편의를 위해 Callback Queue로 통합하여 명칭합니다.</li>
    </ul>
  </li>
  <li>Web api: Web api는 브라우저에서 자체 지원하는 api입니다. Web api는 Dom 이벤트, Ajax (XmlHttpRequest), setTimeout 등의 비동기 작업들을 수행할 수 있도록 api를 지원합니다.</li>
</ul>

<p>다음은 런타임 환경에서 비동기 코드가 실행되는 과정을 살펴보자.</p>

<p>JS 코드들이 실행될 때, Web api가 지원하는 비동기 작업을 수행하는 코드가 실행된다고 생각해보자. 비동기 작업을 수행하는 코드는 아래의 순서로 실행된다.</p>

<ol>
  <li>먼저 이 코드는 호출스택에 쌓인 후 실행되면, Javascript의 엔진은 비동기 작업을 Web api에게 위임합니다.</li>
  <li>Web api는 해당 비동기 작업을 수행하고 콜백 함수를 이벤트 루프를 통해 태스크 큐에 넘겨주게 됩니다.</li>
  <li>이벤트 루프는 콜스택에 쌓여있는 함수가 없을 때에, 태스크 큐에서 대기하고 있던 콜백함수를 콜스택으로 넘겨줍니다</li>
  <li>콜스택에 쌓인콜백함수가 실행되고, 콜스택에서 제거됩니다.</li>
</ol>

<p>위에서 언급했었던 논블로킹 I/O의 개념이 이 부분을 통해 설명된다.<br />
만약 http 요청의 작업을 동기로 수행했다면 해당 함수가 콜스택에 쌓인채로 머물것이고, JS엔진은 해당 작업이 끝날때까지 어떠한 작업도 수행할 수 없다. 즉, 동기 작업이 다른 코드들을 블로킹한 것이다. 그러나 Javascript는 비동기 작업들을 Web api에게 넘겨줌으로써, 해당 작업이 완료될때까지 다른 코드들을 실행할 수 있다. 이것이 바로 논블로킹이다.</p>

<p>간단한 예시를 통해 확인해보자.</p>

<pre><code class="language-JS">console.log('첫번째로 실행됩니다.');
setTimeout(() =&gt; console.log('최소 1초 후에 실행됩니다.'), 1000);
console.log('언제 실행될까요?');
</code></pre>

<p>출력순서</p>

<pre><code class="language-Terminal">첫번째로 실행됩니다.
언제 실행될까요?
최소 1초 후에 실행됩니다.
</code></pre>

<p>동작 순서</p>

<ol>
  <li>제일 먼저 console.log(‘첫번째로 실행됩니다.’)가 콜스택에 쌓이고, 이는 바로 실행되어 제거됩니다.</li>
  <li>그 다음으로 setTimeout이 콜스택에 쌓입니다. setTimeout이 실행되고, Web api에서 timer가 생성됩니다.
console.log(‘언제 실행될까요?’)가 콜스택에 쌓인 후, 바로 실행되고 제거됩니다.</li>
  <li>Web api에서 생성된 timer는 생성된 시점을 기준으로 최소 1초 후에 태스크 큐로 콜백함수를 전달합니다.</li>
  <li>태스크 큐에 전달되어있던 setTimeout의 콜백함수가 콜스택에 스택이 없는것을 확인한 후, 콜스택에 호출되어 실행됩니다.</li>
</ol>

<h2 id="참고">참고</h2>

<p>블로그 - <a href="https://codingjuny.tistory.com/58">Node JS 동작 원리</a></p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Node" /><summary type="html"><![CDATA[Node.js가 나오게 된 환경]]></summary></entry><entry><title type="html">알고리즘</title><link href="http://localhost:4000/til/2023/03/03/algorithm.html" rel="alternate" type="text/html" title="알고리즘" /><published>2023-03-03T00:00:00+09:00</published><updated>2023-03-03T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/03/03/algorithm</id><content type="html" xml:base="http://localhost:4000/til/2023/03/03/algorithm.html"><![CDATA[<h2 id="알고리즘-평가">알고리즘 평가</h2>

<p>알고리즘 평가하는 요소는 크게 두 가지가 있다.<br />
하나는 ‘속도’에 관한 것이고 다른 하나는 ‘메모리의 사용량’에 관한 것이다.<br />
속도에 해당하는 알고리즘 수행시간 분석결과를 ‘시간 복잡도(time complexity)’<br />
메모리 사용량에 대한 분석 결과를 ‘공간 복잡도(space complexity)’라 한다.</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Algorithm" /><summary type="html"><![CDATA[알고리즘 평가]]></summary></entry><entry><title type="html">Stack - 계산기</title><link href="http://localhost:4000/til/2023/02/03/Stack-03.html" rel="alternate" type="text/html" title="Stack - 계산기" /><published>2023-02-03T00:00:00+09:00</published><updated>2023-02-03T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/02/03/Stack-03</id><content type="html" xml:base="http://localhost:4000/til/2023/02/03/Stack-03.html"><![CDATA[<h2 id="수식의-표기법">수식의 표기법</h2>

<p>수식의 표기법에는 세 가지가 있다.</p>

<ul>
  <li>중위 표기법(infix notation) -&gt; 3 + 4 / 7</li>
  <li>전위 표기법(prefix notation) -&gt; + 3 / 4 7</li>
  <li>후위 표기법(postfix notation) -&gt; 3 4 5 / +</li>
</ul>

<p>여기서 중요한 점은 전위 표기법과 후위 표기법의 수식은 연산자의 배치순서에 따라 연산 순서가 결정되기 때문에, 두 표기법의 수식을 계산하기 위해서 연산자의 우선순위를 알 필요가 없고, 소괄호도 삽입되지 않으니 소괄호에 대한 처리도 불필요하다는 점이다.<br />
즉 구현할 계산기는 다음의 과정을 거쳐서 연산을 진행할 계획이다.</p>

<ol>
  <li>중위 표기법의 수식을 후위 표기법의 수식으로 바꾼다.</li>
  <li>후위 표기법으로 바뀐 수식을 꼐산하여 그 결과를 얻는다.</li>
</ol>

<p>중위 표기법의 수식을 후위 표기법의 수식으로 바꾸는 과정은 다음과 같이 정리할 수 있다.</p>

<ol>
  <li>피연산자는 그냥 옮긴다.</li>
  <li>연산자는 스택으로 옮긴다.</li>
  <li>연산자가 스택에 있다면 우선순위를 비교하여 처리방법을 결정한다. - 우선 순위가 낮은 것부터 스택에 쌓아야한다. 나중에 들어온 연산자가 스택에 있는 연산자의 우선순위보다 낮다면 스택에 있는 연산자를 빼고 넣는다. / 사칙연산의 경우 연산자의 우선순위가 동일하다면, 먼저 등장한 연산자가 우선순위가 높다.</li>
  <li>마지막까지 스택에 남아있는 연산자들은 하나씩 꺼내서 옮긴다.</li>
</ol>

<h2 id="중위-표기법을-후위-표기법으로">중위 표기법을 후위 표기법으로</h2>

<h3 id="infixtopostfix-header-file">InfixToPostfix header file</h3>
<pre><code class="language-InfixToPostfix.h">#ifndef __INFIX_TO_POSTFIX_H__
#define __INFIX_TO_POSTFIX_H__

// 중위 표기법을 후위 표기법으로 바꾸는 함수.
void ConvToRPNExp(char exp[]);

#endif
</code></pre>

<h3 id="infixtopostfix-source-file">InfixToPostfix source file</h3>
<pre><code class="language-InfixToPostfix.c">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include "ListBaseStack.h"

// 연산자의 우선순위를 반환해주는 함수.
int GetOpPrec(char op)
{
  switch(op)
  {
    case '*':
    case '/':
      return 5;

    case '+':
    case '-':
      return 3;

    case '(':
      return 1;
  }

  return -1;
}

// 두 연산자의 우선순위를 비교해주는 함수.
int WhoPrecOp(char op1, char op2)
{
  int op1Prec = GetOpPrec(op1);
  int op2Prec = GetOpPrec(op2);

  if(op1Prec &gt; op2Prec)
    return 1;
  else if(op1Prec &lt; op2Prec)
    return -1;
  else
    return 0;
}

void ConvToRPNExp(char exp[])
{
  Stack stack;
  int expLen = strlen(exp);
  char *convExp = (char*)malloc(expLen + 1);
  
  int idx = 0;
  char tok, popOp;

  memset(convExp, 0, sizeof(char)*expLen + 1);
  StackInit(&amp;stack);

  for(int i = 0; i &lt; expLen; i++)
  {
    tok = exp[i];
    if(isdigit(tok))  // 피연산자라면 그대로 옮기기
      convExp[idx++] = tok;
    else
    {
      switch(tok)
      {
        case '(':
          SPush(&amp;stack, tok);
          break;
        case ')':
          while(1)    // ')'가 나왔다면 괄호로 쌓인 연산자 변환식에 옮기기.
          {
            popOp = SPop(&amp;stack);
            if(popOp == '(')
              break;
            convExp[idx++] = popOp;
          }
          break;
        case '+':
        case '-':
        case '*':
        case '/':
          while(!SIsEmpty(&amp;stack) &amp;&amp; (WhoPrecOp(SPeek(&amp;stack), tok) &gt;= 0))
            convExp[idx++] = SPop(&amp;stack);
            
          SPush(&amp;stack, tok);
          break;
      }
    }
  }

  // 스택에 쌓인 연산자 변환하는 식에 넣기.
  while(!SIsEmpty(&amp;stack))
    convExp[idx++] = SPop(&amp;stack);

  // 변환된 후위 표기식 복사하기
  strcpy(exp, convExp);
  free(convExp);
}
</code></pre>

<h3 id="infixtopostfixmainc">InfixToPostfixMain.c</h3>
<pre><code class="language-InfixToPostfixMain.c">#include &lt;stdio.h&gt;
#include "InfixToPostfix.h"

int main(void)
{
  char exp1[] = "1+2*3";
  char exp2[] = "(1+2)*3";
  char exp3[] = "((1+2)+3)*(5-2)";

  ConvToRPNExp(exp1);
  ConvToRPNExp(exp2);
  ConvToRPNExp(exp3);

  printf("%s\n", exp1);
  printf("%s\n", exp2);
  printf("%s\n", exp3);

  return 0;
}
</code></pre>

<h2 id="후위-표기법으로-계산하기">후위 표기법으로 계산하기</h2>
<p>계산 방법 : 후위 표기법을 읽다가 연산자가 나온다면 앞의 두 피연산자를 계산.
ex) 1 2 3 * + = 1 6 + = 7<br />
따라서 연산 과정을 다음과 같이 정리할 수 있다.</p>
<ol>
  <li>후위 표기법으로 표현된 식을 앞에서 부터 읽어 스택에 저장.</li>
  <li>하나씩 저장하다 연산자를 만나면 스택에 저장되어 있는 피연산자 두개를 꺼내 연산후 다시 스택에 저장.</li>
  <li>표현식을 다 읽을 때까지 1,2를 반복.</li>
</ol>

<h3 id="postcalcular-header-file">PostCalcular header file</h3>
<pre><code class="language-PostCalcular.h">#ifndef __POST_CALCULAR_H__
#define __POST_CALCULAR_H__

// 표현식을 인자로 넣으면 계산 값을 반환.
int EvalRPNExp(char exp[]);

#endif
</code></pre>

<h3 id="postcalcular-source-file">PostCalcular source file</h3>
<pre><code class="language-PostCalcular.c">#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include "ListBaseStack.h"

int EvalRPNExp(char exp[])
{
    Stack stack;
    int expLen = strlen(exp);
    char tok, op1, op2;

    StackInit(&amp;stack);

    for(int i = 0; i &lt; expLen; i++)
    {
        tok = exp[i];

        if(isdigit(tok))
            SPush(&amp;stack, tok - '0');
        else
        {
            op2 = SPop(&amp;stack);
            op1 = SPop(&amp;stack);

            switch(tok)
            {
                case '+':
                    SPush(&amp;stack, op1 + op2);
                    break;
                case '-':
                    SPush(&amp;stack, op1 - op2);
                    break;
                case '*':
                    SPush(&amp;stack, op1 * op2);
                    break;
                case '/':
                    SPush(&amp;stack, op1 / op2);
                    break;
            }
        }
    }

    return SPop(&amp;stack);
}
</code></pre>

<h3 id="postcalcularmainc">PostCalcularMain.c</h3>
<pre><code class="language-PostCalcularMain.c">#include &lt;stdio.h&gt;
#include "ListBaseStack.h"
#include "PostCalcular.h"

int main(void)
{
    char *exp1 = "123*+";
    char *exp2 = "12+3*";
    char *exp3 = "12+3+52-*";

    printf("%s = %d\n", exp1, EvalRPNExp(exp1));
    printf("%s = %d\n", exp1, EvalRPNExp(exp2));
    printf("%s = %d\n", exp1, EvalRPNExp(exp3));

    return 0;
}
</code></pre>

<h2 id="합치기">합치기</h2>
<p>InfixToPostfix.h와 PostCalculator.h을 합쳐 InfixCalculator로 만들고 실행시켜보자</p>

<h3 id="infixcalculatorh">InfixCalculator.h</h3>

<pre><code class="language-InfixCalculator.h">#ifndef __INFIX_CALCULATOR_H__
#define __INFIX_CALCULATOR_H__

// 중위 표기법 표현식을 넣으면 값 반환
int EvalInfixExp(char exp[]);

#endif
</code></pre>

<h3 id="infixcalculatorc">InfixCalculator.c</h3>
<pre><code class="language-InfixCalculator.c">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "InfixToPostfix.h"
#include "PostCalcular.h"

int EvalInfixExp(char exp[])
{
    int strLen = strlen(exp);
    int result;
    char *expcpy = (char*)malloc((strLen + 1)*sizeof(char));

    strcpy(expcpy, exp);

    ConvToRPNExp(expcpy);

    result = EvalRPNExp(expcpy);

    free(expcpy);

    return result;
}
</code></pre>

<h3 id="infixcalculatormainc">InfixCalculatorMain.c</h3>
<pre><code class="language-InfixCalculatorMain.c">#include &lt;stdio.h&gt;
#include "InfixCalculator.h"

int main(void)
{
    char exp1[] = "1+2*3";
    char exp2[] = "(1+2)*3";
    char exp3[] = "((1-2)+3)*(5-2)";

    printf("%s = %d\n", exp1, EvalInfixExp(exp1));
    printf("%s = %d\n", exp2, EvalInfixExp(exp2));
    printf("%s = %d\n", exp3, EvalInfixExp(exp3));

    return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[수식의 표기법]]></summary></entry><entry><title type="html">Stack - 리스트 기반</title><link href="http://localhost:4000/til/2023/02/02/Stack-02.html" rel="alternate" type="text/html" title="Stack - 리스트 기반" /><published>2023-02-02T00:00:00+09:00</published><updated>2023-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/02/02/Stack-02</id><content type="html" xml:base="http://localhost:4000/til/2023/02/02/Stack-02.html"><![CDATA[<h2 id="연결-리스트-기반-stack">연결 리스트 기반 Stack</h2>

<p>스택도 연결 리스트이다. 다만 저장된 순서의 역순으로 조회(삭제)가 가능한 연결 리스트일 뿐이다.<br />
우리는 연결리스트를 head만 있는 연결리스트와 head와 tail 둘 다 있는 연결리스트를 만들 수 있다.<br />
여기서 주목할 점은 head만 있는 연결리스트는 stack의 구조와 유사하다는 점이다.<br />
즉 새로운 노드를 꼬리가 아닌 머리에 추가하는 형태로 구현한 연결 리스트가 스택의 구조와 매우 유사한 성격을 지닌다.</p>

<h3 id="adt">ADT</h3>

<p>list기반 Stack의 ADT 또한 배열기반 Stack의 ADT와 동일하다.</p>

<pre><code class="language-ADT">void StackInit(Stack *pstack);
- 스택의 초기화를 진행한다.
- 스택 생성 후 가장 먼저 호출되어야 한다.

int SIsEmpty(Stack *pstack);
- 스택이 빈 경우 TRUE(1)을, 그렇지 않은 경우 FALSE(0)을 반환한다.

void SPush(Stack *pstack, Data data);
- 스택에 데이터를 저장한다. 매개변수 data로 전달된 값을 저장한다.

Data SPop(Stack *pstack);
- 마지막에 저장된 요소를 삭제한다.
- 삭제된 데이터는 반환이 된다.
- 본 함수의 호출을 위해서는 데이터가 하나 이상 존재해야한다.

Data SPeek(Stack *pstack);
- 마지막에 저장된 요소를 반환하되 삭제하지 않는다.
- 본 함수의 호출을 위해서는 데이터가 하나 이상 존재해야한다.
</code></pre>

<h3 id="header-file">header file</h3>

<p>list 기반 Stack을 구현하기 위해서 필요한 것은 포인터 변수 head하나이므로 이를 헤더파일로 정의하면 다음과 같다.</p>

<pre><code class="language-ListBaseStack.h">#ifndef __LB_STACK_H__
#define __LB_STACK_H__

#define TRUE 1
#define FALSE 0
#define STACK_LEN 100

typedef int Data;

typedef struct _node
{
  Data data;
  struct _node *next;
} Node;

typedef struct _listStack
{
  Node *head;
}ListStack;

typedef ListStack Stack;

void StackInit(Stack *pstack);          // 스택의 초기화
int SIsEmpty(Stack *pstack);            // 스택이 비었는지 확인

void SPush(Stack *pstack, Data data);   // 스택의 push연산
Data SPop(Stack *pstack);               // 스택의 pop연산
Data SPeek(Stack *pstack);              // 스택의 peek연산


#endif
</code></pre>

<h3 id="source-file">source file</h3>

<pre><code class="language-ListBaseStack.c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "ListBaseStack.h"

void StackInit(Stack *pstack)
{
  pstack-&gt;head = NULL;
}

int SIsEmpty(Stack *pstack)
{
  if(pstack-&gt;head == NULL)
    return TRUE;
  else
    return FALSE;
}

void SPush(Stack *pstack, Data data)
{
  // 새로운 노드 생성 및 데이터 저장.
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  newNode-&gt;next = pstack-&gt;head;
  pstack-&gt;head = newNode;
}

Data SPop(Stack *pstack)
{
  Node *delNode;
  Data delData;

  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!\n");
    exit(-1);
  }

  delNode = pstack-&gt;head;
  delData = delNode-&gt;data;

  pstack-&gt;head = pstack-&gt;head-&gt;next;

  free(delNode);

  return delData;
}

Data SPeek(Stack *pstack)
{
  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!\n");
    exit(-1);
  }

  return pstack-&gt;head-&gt;data;
}
</code></pre>

<h3 id="mainc">main.c</h3>

<pre><code class="language-ListBaseStackMain.c">#include &lt;stdio.h&gt;
#include "ListBaseStack.h"

int main(void)
{
  // Stack의 생성 및 초기화
  Stack stack;
  StackInit(&amp;stack);

  // 데이터 저장
  SPush(&amp;stack, 11);
  SPush(&amp;stack, 22);
  SPush(&amp;stack, 33);
  SPush(&amp;stack, 44);
  SPush(&amp;stack, 55);

  // 데이터 꺼내기
  while(!SIsEmpty(&amp;stack))
  {
    printf("%d ", SPop(&amp;stack));
  }

  return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[연결 리스트 기반 Stack]]></summary></entry><entry><title type="html">Stack - 배열 기반</title><link href="http://localhost:4000/til/2023/02/01/Stack-01.html" rel="alternate" type="text/html" title="Stack - 배열 기반" /><published>2023-02-01T00:00:00+09:00</published><updated>2023-02-01T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/02/01/Stack-01</id><content type="html" xml:base="http://localhost:4000/til/2023/02/01/Stack-01.html"><![CDATA[<h2 id="stack">Stack</h2>

<p>스택의 구조는 매우 간단하다. 스택은 쟁반 위에 쌓인 접시라고 생각하면 이해하기 쉽다. 쟁반 위에 쌓인 접시는 가장 먼저 쌓은 접시는 맨 밑에 가장 늦게 쌓은 접시는 가장 위에 놓여 있으며, 접시를 뺄 때에는 가장 늦게 쌓인 접시가 제일 먼저 뺄 수 있다는 것을 알 수 있다. 이처럼 스택은 ‘LIFO(Last-In, First-Out) 구조의 자료 구조이다. 즉 후입선출 방식의 자료구조를 뜻한다는 말이다.</p>

<h3 id="adt">ADT</h3>

<p>Stack의 ADT는 다음과 같다.</p>

<pre><code class="language-ADT">void StackInit(Stack *pstack);
- 스택의 초기화를 진행한다.
- 스택 생성 후 가장 먼저 호출되어야 한다.

int SIsEmpty(Stack *pstack);
- 스택이 빈 경우 TRUE(1)을, 그렇지 않은 경우 FALSE(0)을 반환한다.

void SPush(Stack *pstack, Data data);
- 스택에 데이터를 저장한다. 매개변수 data로 전달된 값을 저장한다.

Data SPop(Stack *pstack);
- 마지막에 저장된 요소를 삭제한다.
- 삭제된 데이터는 반환이 된다.
- 본 함수의 호출을 위해서는 데이터가 하나 이상 존재해야한다.

Data SPeek(Stack *pstack);
- 마지막에 저장된 요소를 반환하되 삭제하지 않는다.
- 본 함수의 호출을 위해서는 데이터가 하나 이상 존재해야한다.
</code></pre>

<h3 id="header-file">header file</h3>

<p><img width="739" alt="ArrayBaseStack" src="https://user-images.githubusercontent.com/101408068/226134286-b93c7b13-ba2b-4e0f-971f-cdf14970730b.png" />&lt;/img&gt;
위 그림에서 주목해야 할 것은 두 가지이다.</p>

<ul>
  <li>인데스 0의 배열 요소가 ‘스택의 바닥’으로 정의되어 있다.</li>
  <li>마지막에 저장된 데이터의 위치를 기억해야 한다.(TOP)</li>
</ul>

<p>인데스 0의 배열 요소를 스택의 바닥으로 두어 배열의 길이에 상관 없이 언제나 인덱스 0의 요소가 스택의 바닥이 된다.<br />
스택의 핵심 연산 두 가지는 다음과 같다.</p>

<ul>
  <li>push : Top을 위로 한 칸 올리고, Top이 가리키는 위치에 데이터 저장</li>
  <li>pop : Top이 가리키는 데이터를 반환하고, Top을 아래로 한 칸 내림</li>
</ul>

<pre><code class="language-ArrayBaseStack.h">#ifndef __AB_STACK_H__
#define __AB_STACK_H__

#define TRUE 1
#define FALSE 0
#define STACK_LEN 100

typedef int Data;

typedef struct _arrayStack
{
  Data stackArr[STACK_LEN];
  int topIndex;
} ArrayStack;

typedef ArrayStack Stack;

void StackInit(Stack *pstack);          // 스택의 초기화
int SIsEmpty(Stack *pstack);            // 스택이 비었는지 확인

void SPush(Stack *pstack, Data data);   // 스택의 push연산
Data SPop(Stack *pstack);               // 스택의 pop연산
Data SPeek(Stack *pstack);              // 스택의 peek연산


#endif
</code></pre>

<h3 id="source-file">source file</h3>

<pre><code class="language-ArrayBaseStack.c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "ArrayBaseStack.h"

void StackInit(Stack *pstack)
{
  pstack-&gt;topIndex = -1;        // -1은 빈 상태를 의미한다.
}

int SIsEmpty(Stack *pstack)
{
  if(pstack-&gt;topIndex == -1)
    return TRUE;
  else
    return FALSE;
}

void SPush(Stack *pstack, Data data)
{
  pstack-&gt;topIndex++;
  pstack-&gt;stackArr[pstack-&gt;topIndex] = data;
}

Data SPop(Stack *pstack)
{
  int delIndex;

  if(SIsEmpty(pstack))                  // Stack이 비어있다면
  {
    printf("Stack Memory Error!\n");
    exit(-1);
  }

  delIndex = pstack-&gt;topIndex;          // 삭제할 index값 저장
  pstack-&gt;topIndex--;                   // pop 연산으로 인해 topIndex 값 하나 감소

  return pstack-&gt;stackArr[delIndex];    // 삭제되는 데이터 반환
}

Data SPeek(Stack *pstack)
{
  if(SIsEmpty(pstack))
  {
    printf("Stack Memory Error!\n");
    exit(-1);
  }

  return pstack-&gt;stackArr[pstack-&gt;topIndex];
}
</code></pre>

<h3 id="mainc">main.c</h3>

<pre><code class="language-ArrayBaseStackMain.c">#include &lt;stdio.h&gt;
#include "ArrayBaseStack.h"

int main(void)
{
  // Stack의 생성 및 초기화
  Stack stack;
  StackInit(&amp;stack);

  // 데이터 저장
  SPush(&amp;stack, 11);
  SPush(&amp;stack, 22);
  SPush(&amp;stack, 33);
  SPush(&amp;stack, 44);
  SPush(&amp;stack, 55);

  // 데이터 꺼내기
  while(!SIsEmpty(&amp;stack))
  {
    printf("%d ", SPop(&amp;stack));
  }

  return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조<br />
블로그 - <a href="https://hellmath.tistory.com/7">스택의 개념, 배열로 스택구현</a></p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[Stack]]></summary></entry><entry><title type="html">리스트 - 5</title><link href="http://localhost:4000/til/2023/01/31/Linked-List-05.html" rel="alternate" type="text/html" title="리스트 - 5" /><published>2023-01-31T00:00:00+09:00</published><updated>2023-01-31T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/01/31/Linked-List-05</id><content type="html" xml:base="http://localhost:4000/til/2023/01/31/Linked-List-05.html"><![CDATA[<h2 id="양방향-연결-리스트---headdummynode와-taildummynode가-있는-것">양방향 연결 리스트 - headDummyNode와 tailDummyNode가 있는 것</h2>

<ul>
  <li>장점
    <ul>
      <li>DummyNode를 head와 tail에 추가함으로써 삭제와 조회의 일관성을 더한다.</li>
    </ul>
  </li>
</ul>

<h3 id="adt">ADT</h3>

<pre><code class="language-ADT">void List Init(List *plist);
- 리스트 초기화

void LInsert(List *plist, LData pdata);
- 리스트에 데이터 저장

int LFirst(List *plist, LData pdata);
- 첫 번째 데이터를 pdata에 저장
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

int LNext(List *plist, LData *pdata);
- 참조된 데이터의 다음 데이터를 pdata에 저장
- 참조를 새로 시작하기 위해선 LFirst 함수를 호출해야 한다.
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

LData LRemove(List *plist);
- LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
- 삭제된 데이터를 반환

int LCount(List *plist);
- 리스트에 저장되어 있는 데이터의 수 반환
</code></pre>

<h3 id="header-file">header file</h3>

<pre><code class="language-DBLinkedList.h">#ifndef __DB_LINKED_LIST_H__
#define __DB_LINKED_LIST_H__

#define TRUE 1
#define FALSE 0

typedef int Data;

typedef struct _node
{
  Data data;
  struct _node *prev;
  struct _node *next;
}Node;

typedef struct _DLinkedList
{
  Node *head;
  Node *tail;
  Node *cur;
  int numOfData;

}DBLinkedList;

typedef DBLinkedList List;

void ListInit(List *plist);                 // 초기화
void LInsert(List *plist, Data data);       // 머리에 데이터 저장

int LFirst(List *plist, Data *pdata);       // 첫 데이터 참조
int LNext(List *plist, Data *pdata);        // 두 번째 이후 데이터 참조

Data LRemove(List *plist);                  // 참조한 데이터 삭제
int LCount(List *plist);                    // 저장된 데이터의 수 반환


#endif
</code></pre>

<h3 id="source-file">source file</h3>

<pre><code class="language-DBLinkedList.c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "DBLinkedList.h"

void ListInit(List *plist)
{
  Node *headDummy = (Node*)malloc(sizeof(Node));
  Node *tailDummy = (Node*)malloc(sizeof(Node));

  // headDummy 연결.
  headDummy-&gt;prev = NULL;
  headDummy-&gt;next = tailDummy;
  plist-&gt;head = headDummy;

  // tailDummy 연결
  tailDummy-&gt;prev = headDummy;
  tailDummy-&gt;next = NULL;
  plist-&gt;tail = tailDummy;

  plist-&gt;numOfData = 0;
}

void LInsert(List *plist, Data data)
{
  // 저장할 노드 생성
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  // newNode와 다음 Node 연결
  newNode-&gt;next = plist-&gt;head-&gt;next;
  plist-&gt;head-&gt;next-&gt;prev = newNode;

  // headDummy와 newNode 연결
  newNode-&gt;prev = plist-&gt;head;
  plist-&gt;head-&gt;next = newNode;

  plist-&gt;numOfData++;
}

int LFirst(List *plist, Data *pdata)
{
  if(plist-&gt;head-&gt;next == plist-&gt;tail)
    return FALSE;

  plist-&gt;cur = plist-&gt;head-&gt;next;
  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

int LNext(List *plist, Data *pdata)
{
  if(plist-&gt;cur-&gt;next == plist-&gt;tail)
    return FALSE;

  plist-&gt;cur = plist-&gt;cur-&gt;next;
  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

Data LRemove(List *plist)
{
  Node *delNode;
  Data delData;

  delNode = plist-&gt;cur;
  delData = delNode-&gt;data;

  delNode-&gt;prev-&gt;next = delNode-&gt;next;
  delNode-&gt;next-&gt;prev = delNode-&gt;prev;
  plist-&gt;cur = delNode-&gt;prev;
  free(delNode);

  plist-&gt;numOfData--;

  return delData;
}

int LCount(List *plist)
{
  return plist-&gt;numOfData;
}
</code></pre>

<h3 id="mainc">main.c</h3>

<pre><code class="language-DBLinkedListMain.c">#include &lt;stdio.h&gt;
#include "DBLinkedList.h"

int main(void)
{
  List list;
  Data data;

  ListInit(&amp;list);

  LInsert(&amp;list, 11);
  LInsert(&amp;list, 22);
  LInsert(&amp;list, 33);
  LInsert(&amp;list, 44);
  LInsert(&amp;list, 55);

  printf("저장된 데이터 수 : %d\n", LCount(&amp;list));

  if(LFirst(&amp;list, &amp;data))
  {
    printf("data : %d\n", data);

    while(LNext(&amp;list, &amp;data))
    {
      printf("data : %d\n", data);
    }
  }

  if(LFirst(&amp;list, &amp;data))
  {
    if(data == 11 || data == 33 || data == 55)
    {
      printf("삭제된 데이터 : %d\n", LRemove(&amp;list));
    }

    while(LNext(&amp;list, &amp;data))
    {
      if(data == 11 || data == 33 || data == 55)
        printf("삭제된 데이터 : %d\n", LRemove(&amp;list));
    }
  }


  if(LFirst(&amp;list, &amp;data))
  {
    printf("data : %d\n", data);

    while(LNext(&amp;list, &amp;data))
    {
      printf("data : %d\n", data);
    }
  }

  printf("저장된 데이터 수 : %d\n", LCount(&amp;list));

  return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[양방향 연결 리스트 - headDummyNode와 tailDummyNode가 있는 것]]></summary></entry><entry><title type="html">리스트 - 4</title><link href="http://localhost:4000/til/2023/01/30/Linked-List-04.html" rel="alternate" type="text/html" title="리스트 - 4" /><published>2023-01-30T00:00:00+09:00</published><updated>2023-01-30T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/01/30/Linked-List-04</id><content type="html" xml:base="http://localhost:4000/til/2023/01/30/Linked-List-04.html"><![CDATA[<h2 id="양방향-연결-리스트">양방향 연결 리스트</h2>

<ul>
  <li>장점
    <ul>
      <li>기존의 단순 연결 리스트는 한쪽 방향으로만 조회가 가능하기 때문에 삭제를 위해 before이라는 멤버 변수를 유지해야하지만 양뱡향 연결 리스트는 그럴 필요가 없다.</li>
    </ul>
  </li>
</ul>

<p>양방향 연결 리스트는 하나의 노드가 자신의 왼쪽과 오른쪽 노드를 동시에 가리키는 구조이다.<br />
따라서 양방향 연결 리스트의 노드를 표현하는 구조체는 다음과 같다.</p>

<pre><code class="language-Node">typedef struct _node
{
  Data data;
  struct _node *prev;
  struct _node *next;
} Node;
</code></pre>

<h3 id="adt">ADT</h3>

<pre><code class="language-ADT">void List Init(List *plist);
- 리스트 초기화

void LInsert(List *plist, LData pdata);
- 리스트에 데이터 저장

int LFirst(List *plist, LData pdata);
- 첫 번째 데이터를 pdata에 저장
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

int LNext(List *plist, LData *pdata);
- 참조된 데이터의 다음 데이터를 pdata에 저장
- 참조를 새로 시작하기 위해선 LFirst 함수를 호출해야 한다.
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

int LPrevious(List *plist, Data *pdata);
- 참조된 데이터의 역순 데이터를 pdata에 저장
- 참조를 새로 시작하기 위해선 LFirst 함수를 호출해야 한다.
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

LData LRemove(List *plist);
- LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
- 삭제된 데이터를 반환

int LCount(List *plist);
- 리스트에 저장되어 있는 데이터의 수 반환
</code></pre>

<h3 id="header-file">header file</h3>

<pre><code class="language-DBLinkedList.h">#ifndef __DB_LINKED_LIST_H__
#define __DB_LINKED_LIST_H__

#define TRUE 1
#define FALSE 0

typedef int Data;

typedef struct _node
{
  Data data;
  struct _node *prev;
  struct _node *next;
}Node;

typedef struct _DLinkedList
{
  Node *head;
  Node *cur;
  int numOfData;

}DBLinkedList;

typedef DBLinkedList List;

void ListInit(List *plist);                 // 초기화
void LInsert(List *plist, Data data);       // 머리에 데이터 저장

int LFirst(List *plist, Data *pdata);       // 첫 데이터 참조
int LNext(List *plist, Data *pdata);        // 두 번째 이후 데이터 참조
int LPrevious(List *plist, Data *pdata);    // LNext 함수의 반대 방향 노드 참조

Data LRemove(List *plist);                  // 참조한 데이터 삭제
int LCount(List *plist);                    // 저장된 데이터의 수 반환


#endif
</code></pre>

<h3 id="source-file">source file</h3>

<pre><code class="language-DBLinkedList.c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "DBLinkedList.h"

void ListInit(List *plist)
{
  plist-&gt;head = NULL;
  plist-&gt;numOfData = 0;
}

void LInsert(List *plist, Data data)
{
  /*
  // 저장할 노드 생성
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  if(plist-&gt;head == NULL)               // 데이터를 처음 추가할 때
  {
    newNode-&gt;next = NULL;
    newNode-&gt;prev = NULL;
    plist-&gt;head = newNode;
  }
  else
  {
    newNode-&gt;next = plist-&gt;head;        // 새 노드가 다음 노드를 가리키게 연결
    newNode-&gt;prev = NULL;               // 새 노드의 prev는 NULL을 가리킴
    plist-&gt;head-&gt;prev = newNode;        // 새 노드가 가리키는 노드 즉 새로 추가된 노드의 앞에 있는 노드의 prev가 새 노드를 가리키게 연결
    plist-&gt;head = newNode;              // head가 새 노드를 가리키도록 연결
  }

  plist-&gt;numOfData++;

  조건문 안에 3문장이 중복된다.
  처음 데이터를 추가할 때 plist-&gt;head는 NULL을 가리키므로 다음과 같은 함수로 만들 수 있다.
  */

  // 저장할 노드 생성
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  newNode-&gt;next = plist-&gt;head;
  newNode-&gt;prev = NULL;

  if(plist-&gt;head != NULL)               // 두 번째 이후의 노드를 추가할 때
  {
    plist-&gt;head-&gt;prev = newNode;
  }
  plist-&gt;head = newNode;                // head가 새 노드를 가리키도록 연결

  plist-&gt;numOfData++;
}

int LFirst(List *plist, Data *pdata)
{
  if(plist-&gt;head == NULL)
    return FALSE;

  plist-&gt;cur = plist-&gt;head;
  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

int LNext(List *plist, Data *pdata)
{
  if(plist-&gt;cur-&gt;next == NULL)
    return FALSE;

  plist-&gt;cur = plist-&gt;cur-&gt;next;
  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

int LPrevious(List *plist, Data *pdata)
{
  if(plist-&gt;cur-&gt;prev == NULL)
    return FALSE;

  plist-&gt;cur = plist-&gt;cur-&gt;prev;
  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

Data LRemove(List *plist)
{
  Node *delNode;
  Data delData;

  delNode = plist-&gt;cur;
  delData = delNode-&gt;data;

  if(delNode == plist-&gt;head)  // 삭제할 노드를 head인 경우
  {
    delNode-&gt;next-&gt;prev = NULL;
    plist-&gt;head = delNode-&gt;next;
    plist-&gt;cur = plist-&gt;head;
    free(delNode);
  }
  else if(delNode-&gt;next == NULL) // 삭제할 노드가 마지막 노드인 경우
  {
    delNode-&gt;prev-&gt;next = NULL;
    free(delNode);
  }
  else
  {
    delNode-&gt;prev-&gt;next = delNode-&gt;next;
    delNode-&gt;next-&gt;prev = delNode-&gt;prev;
    plist-&gt;cur = delNode-&gt;prev;
    free(delNode);
  }

  plist-&gt;numOfData--;

  return delData;
}

int LCount(List *plist)
{
  return plist-&gt;numOfData;
}
</code></pre>

<h3 id="mainc">main.c</h3>

<pre><code class="language-DBLinkedListMain.c">#include &lt;stdio.h&gt;
#include "DBLinkedList.h"

int main(void)
{
  List list;
  Data data;

  ListInit(&amp;list);

  LInsert(&amp;list, 11);
  LInsert(&amp;list, 22);
  LInsert(&amp;list, 33);
  LInsert(&amp;list, 44);
  LInsert(&amp;list, 55);

  printf("저장된 데이터 수 : %d\n", LCount(&amp;list));

  if(LFirst(&amp;list, &amp;data))
  {
    printf("data : %d\n", data);

    while(LNext(&amp;list, &amp;data))
    {
      printf("data : %d\n", data);
    }

    while(LPrevious(&amp;list, &amp;data))
    {
      printf("data : %d\n", data);
    }
  }

  if(LFirst(&amp;list, &amp;data))
  {
    if(data == 11 || data == 33 || data == 55)
    {
      printf("삭제된 데이터 : %d\n", LRemove(&amp;list));
    }

    while(LNext(&amp;list, &amp;data))
    {
      if(data == 11 || data == 33 || data == 55)
        printf("삭제된 데이터 : %d\n", LRemove(&amp;list));
    }
  }


  if(LFirst(&amp;list, &amp;data))
  {
    printf("data : %d\n", data);

    while(LNext(&amp;list, &amp;data))
    {
      printf("data : %d\n", data);
    }
  }
  return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[양방향 연결 리스트]]></summary></entry><entry><title type="html">리스트 - 3</title><link href="http://localhost:4000/til/2023/01/28/Linked-List-03.html" rel="alternate" type="text/html" title="리스트 - 3" /><published>2023-01-28T00:00:00+09:00</published><updated>2023-01-28T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/01/28/Linked-List-03</id><content type="html" xml:base="http://localhost:4000/til/2023/01/28/Linked-List-03.html"><![CDATA[<h2 id="원형-연결-리스트---구현">원형 연결 리스트 - 구현</h2>

<ul>
  <li>장점
    <ul>
      <li>단순 연결 리스트처럼 머리와 꼬리를 가리키는 포인터 변수를 각각 두지 않아도, 하나의 포인터 변수만 있어도 머리 또는 꼬리에 노드를 간단히 추가할 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="adt">ADT</h3>

<p>원형 연결 리스트의 ADT는 단순 연결 리스트의 ADT와 매우 흡사하다.<br />
차이점은 정렬 고려한 SetSortRule이 빠졌으며 데이터 삽입에도 머리에 추가하는 것과 꼬리에 추가하는 것. 두 가지로 나누었다.</p>

<pre><code class="language-ADT">void List Init(List *plist);
- 리스트 초기화

void LInsertFront(List *plist, LData pdata);
- 리스트 머리에 데이터 저장

void LInsert(List *plist, LData pdata);
- 리스트 꼬리에 데이터 저장

int LFirst(List *plist, LData pdata);
- 첫 번째 데이터를 pdata에 저장
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

int LNext(List *plist, LData *pdata);
- 참조된 데이터의 다음 데이터를 pdata에 저장
- 참조를 새로 시작하기 위해선 LFirst 함수를 호출해야 한다.
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

LData LRemove(List *plist);
- LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
- 삭제된 데이터를 반환

int LCount(List *plist);
- 리스트에 저장되어 있는 데이터의 수 반환
</code></pre>

<h3 id="header-file">header file</h3>

<pre><code class="language-CLinkedList.h">#ifndef __C_LINKED_LIST_H__
#define __C_LINKED_LIST_H__

#define TRUE 1
#define FALSE 0

typedef int Data;

typedef struct _node
{
  Data data;
  struct _node *next;
}Node;

typedef struct _CirclelinkedList
{
  Node *tail;
  Node *cur;
  Node *before;
  int numOfData;

}CList;

typedef CList List;

void ListInit(List *plist);                 // 초기화
void LInsert(List *plist, Data data);       // 꼬리에 데이터 저장
void LInsertFront(List *plist, Data data);  // 머리에 데이터 저장

int LFirst(List *plist, Data *pdata);       // 첫 데이터 참조
int LNext(List *plist, Data *pdata);        // 두 번째 이후 데이터 참조

Data LRemove(List *plist);                  // 참조한 데이터 삭제
int LCount(List *plist);                    // 저장된 데이터의 수 반환


#endif
</code></pre>

<h3 id="source-file">source file</h3>

<p>원형 연결 리스트의 삭제 함수는 단순 연결 리스트의 삭제 함수와 매우 유사하지만 2가지의 예외 case에 대해 처리해주어야한다.</p>

<ol>
  <li>삭제할 노드를 tail이 가리키는 경우 -&gt; tail이 가리키는 노드가 삭제되므로 tail이 다른 노드를 가리키도록 해야 한다.</li>
  <li>삭제할 노드가 리스트에 홀로 남은 경우 -&gt; 삭제가 진행되고 나면 포인터 변수 tail은 더 이상 가리킬 노드가 존재하지 않으므로 NULL을 가리키게 해야 한다.</li>
</ol>

<pre><code class="language-CLinkedList.c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "CLinkedList.h"

void ListInit(List *plist)
{
  plist-&gt;tail = NULL;
  plist-&gt;cur = NULL;
  plist-&gt;before = NULL;
  plist-&gt;numOfData = 0;
}

void LInsert(List *plist, Data data)    // 꼬리에 데이터 추가
{
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  if(plist-&gt;tail == NULL)               // 데이터를 처음 추가할 때
  {
    plist-&gt;tail = newNode;
    newNode-&gt;next = newNode;
  }
  else
  {
    newNode-&gt;next = plist-&gt;tail-&gt;next;  // 새 노드가 다시 머리를 가리키도록 연결
    plist-&gt;tail-&gt;next = newNode;        // 꼬리에 있는 마지막 노드가 새 노드를 가리키도록 연결
    plist-&gt;tail = newNode;              // 꼬리가 새 노드를 가리키도록 연결
  }

  plist-&gt;numOfData++;                   // 데이터 수 증가
}

void LInsertFront(List *plist, Data data)
{
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  if(plist-&gt;tail == NULL)               // 데이터를 처음 추가할 때
  {
    plist-&gt;tail = newNode;
    newNode-&gt;next = newNode;
  }
  else
  {
    newNode-&gt;next = plist-&gt;tail-&gt;next;  // 새 노드가 머리에 있는 노드를 가리키도록 연결
    plist-&gt;tail-&gt;next = newNode;        // 꼬리에 있는 노드가 새 노드를 가리키도록 연결
  }

  plist-&gt;numOfData++;                   // 데이터 수 증가
}

int LFirst(List *plist, Data *pdata)
{
  if(plist-&gt;tail == NULL)               // 데이터가 없다면 FALSE 반환
    return FALSE;

  plist-&gt;before = plist-&gt; tail;
  plist-&gt;cur = plist-&gt;tail-&gt;next;       // 원형 리스트이므로 꼬리의 다음 노드는 머리

  *pdata = plist-&gt;cur-&gt;data;            // 데이터 저장

  return TRUE;
}

int LNext(List *plist, Data *pdata)
{
  if(plist-&gt;tail == NULL)               // 데이터가 없다면 FALSE 반환
    return FALSE;

  plist-&gt;before = plist-&gt;cur;
  plist-&gt;cur = plist-&gt;cur-&gt;next;

  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

Data LRemove(List *plist)
{
  Node *delNode = plist-&gt;cur;
  Data delData = delNode-&gt;data;

  if(delNode == plist-&gt;tail)              // 삭제할 데이터가 꼬리를 가리킨다면
  {
    if(plist-&gt;tail == plist-&gt;tail-&gt;next)   // 남은 데이터가 하나라면
      plist-&gt;tail = NULL;
    else
      plist-&gt;tail = plist-&gt;before;
  }
  plist-&gt;before-&gt;next = plist-&gt;cur-&gt;next; // cur 당겨주기
  plist-&gt;cur = plist-&gt;before;
  free(delNode);

  plist-&gt;numOfData--;
  return delData;
}

int LCount(List *plist)
{
  return plist-&gt;numOfData;
}
</code></pre>

<h3 id="mainc">main.c</h3>

<pre><code class="language-CLinkedListMain.c">#include &lt;stdio.h&gt;
#include "CLinkedList.h"

int main(void)
{
  List list;
  Data data;

  ListInit(&amp;list);

  LInsert(&amp;list, 11);
  LInsert(&amp;list, 22);
  LInsert(&amp;list, 33);
  LInsert(&amp;list, 44);
  LInsert(&amp;list, 55);

  printf("데이터 삭제 전\n");
  if(LFirst(&amp;list, &amp;data))
    printf("data : %d\n", data);
  for(int i = 0; i &lt; list.numOfData - 1; i++)
  {
    LNext(&amp;list, &amp;data);
    printf("data : %d\n", data);
  }

  printf("\n");

  if(LFirst(&amp;list, &amp;data))
  {
    if(data == 22 || data == 44)
      printf("삭제된 데이터 : %d\n", LRemove(&amp;list));

    for(int i = 0; i &lt; list.numOfData - 1; i++)
    {
      LNext(&amp;list, &amp;data);
      if(data == 22 || data == 44)
        printf("삭제된 데이터 : %d\n", LRemove(&amp;list));
    }
  }

  printf("데이터 삭제 후\n");

  if(LFirst(&amp;list, &amp;data))
    printf("data : %d\n", data);
  for(int i = 0; i &lt; list.numOfData - 1; i++)
  {
    LNext(&amp;list, &amp;data);
    printf("data : %d\n", data);
  }
  return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[원형 연결 리스트 - 구현]]></summary></entry><entry><title type="html">리스트 - 2</title><link href="http://localhost:4000/til/2023/01/22/Linked-List-02.html" rel="alternate" type="text/html" title="리스트 - 2" /><published>2023-01-22T00:00:00+09:00</published><updated>2023-01-22T00:00:00+09:00</updated><id>http://localhost:4000/til/2023/01/22/Linked-List-02</id><content type="html" xml:base="http://localhost:4000/til/2023/01/22/Linked-List-02.html"><![CDATA[<h2 id="연결-리스트---구현">연결 리스트 - 구현</h2>

<p>새 노드를 추가할 때, 리스트의 머리와 꼬리 둘 중 어디에 저장하는 지에 따라 장단점이 있다.</p>

<ul>
  <li>
    <p>머리에 저장할 경우</p>

    <ul>
      <li>장점
        <ul>
          <li>포인터 변수 tail이 필요 없다.</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>저장된 순서를 유지하지 않는다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>꼬리에 저장할 경우</p>
    <ul>
      <li>장점
        <ul>
          <li>저장된 순서가 유지된다.</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>포인터 변수 tail이 필요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>포인터 변수 tail을 유지하는 것은 낭비이며 리스트는 저장된 순서를 유지하는 자료구조가 아니므로 머리에 추가할 것이다.</p>

<h3 id="adt">ADT</h3>

<pre><code class="language-ADT">void List Init(List *plist);
- 리스트 초기화

void LInsert(List *plist, LData pdata);
- 리스트에 데이터 저장

int LFirst(List *plist, LData pdata);
- 첫 번째 데이터를 pdata에 저장
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

int LNext(List *plist, LData *pdata);
- 참조된 데이터의 다음 데이터를 pdata에 저장
- 참조를 새로 시작하기 위해선 LFirst 함수를 호출해야 한다.
- 참조 성공 시 TRUE(1), 실패 시 FALSE(0)을 반환

LData LRemove(List *plist);
- LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
- 삭제된 데이터를 반환

int LCount(List *plist);
- 리스트에 저장되어 있는 데이터의 수 반환

void SetSortRule(List *plist, int (*comp)(LData d1, LData d2));
- 리스트에 정렬의 기준이 되는 함수를 등록
</code></pre>

<h3 id="header-file">header file</h3>

<p>더미 Node를 추가할 것이다.<br />
=&gt; 첫번째 Node는 포인터 변수 head가 가리키기 때문에 다른 Node들과의 차이가 있다. 즉 Node를 추가, 삭제, 조회에 있어 첫 번째 Node와 두 번째 이후의 Node에 차이가 있기 때문이다. 이를 방지하기 위해 더미 Node를 추가한다.</p>

<pre><code class="language-DLinkedList.h">#ifndef __D_LINKED_LIST_H__
#define __D_LINKED_LIST_H__

#define TRUE 1
#define FALSE 0

typedef int LData;

typedef struct _node
{
  LData data;
  struct _node *next
}Node;

typedef struct _linkedList
{
  Node *head;
  Node *cur;
  Node *before;
  int numOfData;
  int (*comp)(LData d1, LData d2);
}LinkedList;

typedef LinkedList List;

void ListInit(List *plist);                 // 초기화
void LInsert(List *plist, LData data);      // 데이터 저장

int LFirst(List *plist, LData *pdata);      // 첫 데이터 참조
int LNext(List *plist, LData *pdata);       // 두 번째 이후 데이터 참조

LData LRemove(List *plist);                 // 참조한 데이터 삭제
int LCount(List *plist);                    // 저장된 데이터의 수 반환

void SetSortRule(List *plist, int (*comp)(LData d1, LData d2)); // 정렬 기준

#endif
</code></pre>

<h3 id="source-file">source file</h3>

<pre><code class="language-DLINKEDLIST.c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "DLinkedList.h"

void ListInit(List *plist)
{
  plist-&gt;head = (Node*)malloc(sizeof(Node));
  plist-&gt;head-&gt;next = NULL;
  plist-&gt;comp = NULL;
  plist-&gt;numOfData = 0;
}

void FInsert(List *plist, LData data)   // head에 노드 추가
{
  Node *newNode = (Node*)malloc(sizeof(Node));
  newNode-&gt;data = data;

  newNode-&gt;next = plist-&gt;head-&gt;next;    // 새 노드가 다른 노드를 가리키게 함
  plist-&gt;head-&gt;next = newNode;          // 더미 노드가 새 노드를 가리키게 함

  plist-&gt;numOfData++;                   // 저장된 노드의 갯수 증가
}

void SInsert(List *plist, LData data)   // 정렬 기준에 따라 노드 추가
{
  Node *newNode = (Node*)malloc(sizeof(Node));    // 새 노드 생성
  Node *pred = plist-&gt;head;                       // pred는 더미 노드를 가리킴

  newNode-&gt;data = data;                           // 데이터 저장

  // 새 노드가 들어갈 위치 찾기
  while(pred-&gt;next != NULL &amp;&amp; plist-&gt;comp(data, (pred-&gt;next-&gt;data)) != 0)
  {
    pred = pred-&gt;next;
  }

  newNode-&gt;next = pred-&gt;next;                     // 노드 연결
  pred-&gt;next = newNode;

  plist-&gt;numOfData++;                             // 저장된 데이터의 갯수 증가
}

void LInsert(List *plist, LData data)
{
  if(plist-&gt;comp == NULL)   // 정렬 기준이 없다면 head에 노드 추가
    FInsert(plist, data);
  else                      // 정렬 기준이 있다면 정렬 기준으로 노드 추가
    SInsert(plist, data);
}


int LFirst(List *plist, LData *pdata)
{
  if(plist-&gt;head-&gt;next == NULL)         // 더미 노드가 NULL을 가리키면 FALSE를 리턴
    return FALSE;

  plist-&gt;before = plist-&gt;head;          // before은 더미 노드를 가리킴
  plist-&gt;cur = plist-&gt;head-&gt;next;       // cur은 데이터가 있는 첫 번째 노드를 가리킴

  *pdata = plist-&gt;cur-&gt;data;            // 첫 번째 노드의 데이터 전달
  return TRUE;
}

int LNext(List *plist, LData *pdata)
{
  if(plist-&gt;cur-&gt;next == NULL)
    return FALSE;

  plist-&gt;before = plist-&gt;cur;
  plist-&gt;cur = plist-&gt;cur-&gt;next;

  *pdata = plist-&gt;cur-&gt;data;

  return TRUE;
}

LData LRemove(List *plist)
{
  Node *rpos = plist-&gt;cur;
  LData rdata = plist-&gt;cur-&gt;data;

  plist-&gt;before-&gt;next = plist-&gt;cur-&gt;next;      // 삭제 전 노드와 삭제 후 노드를 연결
  plist-&gt;cur = plist-&gt;before;                  // cur 위치 재조정

  free(rpos);                                  // 삭제 노드의 메모리 해제
  plist-&gt;numOfData--;                          // 저장된 노드의 갯수 감소

  return rdata;
}

int LCount(List *plist)
{
  return plist-&gt;numOfData;
}

void SetSortRule(List *plist, int (*comp)(LData d1, LData d2)) // 정렬 기준
{
  plist-&gt;comp = comp;
}
</code></pre>

<h3 id="mainc">main.c</h3>

<pre><code class="language-DLinkedListMain.c">#include &lt;stdio.h&gt;
#include "DLinkedList.h"

// 오름차순 정렬
int WhoIsPrecede(int data1, int data2)
{
  if(data1 &lt; data2)
    return 0;
  else
    return 1;
}


int main(void)
{
  List list;
  int data;

  // 리스트 초기화
  ListInit(&amp;list);

  SetSortRule(&amp;list, WhoIsPrecede);   // 정렬 기준 등록

  // 데이터 저장
  LInsert(&amp;list, 11);
  LInsert(&amp;list, 22);
  LInsert(&amp;list, 33);
  LInsert(&amp;list, 44);
  LInsert(&amp;list, 55);

  printf("저장된 데이터 수 : %d\n", LCount(&amp;list));

  if(LFirst(&amp;list, &amp;data))
  {
    printf("data : %d\n", data);

    while(LNext(&amp;list, &amp;data))
      printf("data : %d\n", data);
  }

  printf("\n\n");

  if(LFirst(&amp;list, &amp;data))
  {
    if(data == 33)
    {
      printf("삭제된 데이터 : %d\n", data);
      LRemove(&amp;list);
    }

    while(LNext(&amp;list, &amp;data))
    {
      if(data == 33)
      {
        printf("삭제된 데이터 : %d\n", data);
        LRemove(&amp;list);
      }
    }
  }

  printf("저장된 데이터 수 : %d\n", LCount(&amp;list));

  if(LFirst(&amp;list, &amp;data))
  {
    printf("data : %d\n", data);

    while(LNext(&amp;list, &amp;data))
      printf("data : %d\n", data);
  }

  return 0;
}
</code></pre>

<h2 id="참고-자료">참고 자료</h2>

<p>책 - 윤성우의 열혈 자료 구조</p>]]></content><author><name>pwsusc10</name></author><category term="TIL" /><category term="TIL" /><category term="Data Structure" /><summary type="html"><![CDATA[연결 리스트 - 구현]]></summary></entry></feed>